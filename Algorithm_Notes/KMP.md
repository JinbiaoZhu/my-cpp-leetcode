# KMP 算法

来源：[代码随想录 ―― 28. 实现 strStr()](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF)

***以下内容是对 Carl 阐述内容的摘录***

### 0. KMP 算法基本介绍

KMP 算法是由这三位学者发明的：Knuth，Morris 和 Pratt，所以取了三位学者名字的首字母。

KMP 的主要思想是 **当出现字符串不匹配时** ，可以知道 **一部分之前已经匹配的文本内容** ，可以利用这些信息 **避免从头再去做匹配** 了。

### 1. 基本概念

1. 模式串：匹配的模板字符串；主串：被匹配的字符串。

   > 要在文本串(被匹配的字符串)： `aabaabaafa` 中查找是否出现过一个模式串(匹配的模板)： `aabaaf` 。

2. 前缀：**不包含最后一个字符的所有以第一个字符开头的连续子串**。

   后缀：**不包含第一个字符的所有以最后一个字符结尾的连续子串**。

   > 分析：字符串 `aabaa` 的最长公共前后缀是什么？有多长？
   >
   > 根据定义求出前缀： `a` 、 `aa` 、 `aab` 、 `aaba` ；
   >
   > 根据定义求出后缀： `abaa` 、 `baa` 、 `aa` 、 `a` ；
   >
   > 公共前后缀是 `a` 和 `aa` ，所以最长前后缀是 `aa` 且长度是 2 。

   **因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

3. 前缀表：**记录下标 i 之前（包括 i ）的字符串中，有多大长度的相同前缀后缀。**

   前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该**从哪里开始重新匹配**。

   前缀表的任务是当前位置匹配失败，<u>找到之前已经匹配上的位置，再重新匹配</u>，此也意味着在某个字符失配时，前缀表会告诉你<u>下一步匹配中，模式串应该跳到哪个位置</u>。

4. 



### 2. 前缀表的代码实现

前缀表的元素 = 第 index 个元素**包括自己的**子字符串的**最长公共前后缀长度值**。

那么 next 数组与前缀表有什么关系呢？ next 数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为 -1 ）之后作为 next 数组。其实这并不涉及到 KMP 算法的原理，而是具体实现， next 数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为 -1 ）。

### 2.1 构造 next 数组





### 3. 如何使用前缀表





