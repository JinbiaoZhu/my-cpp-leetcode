# KMP 算法

来源：[代码随想录 ―― 28. 实现 strStr()](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF)

***以下内容是对 Carl 阐述内容的摘录***

### 0. KMP 算法基本介绍

KMP 算法是由这三位学者发明的：Knuth，Morris 和 Pratt，所以取了三位学者名字的首字母。

KMP 的主要思想是 **当出现字符串不匹配时** ，可以知道 **一部分之前已经匹配的文本内容** ，可以利用这些信息 **避免从头再去做匹配** 了。

### 1. 基本概念

1. 模式串：匹配的模板字符串；主串：被匹配的字符串。

   > 要在文本串(被匹配的字符串)： `aabaabaafa` 中查找是否出现过一个模式串(匹配的模板)： `aabaaf` 。

2. 前缀：**不包含最后一个字符的所有以第一个字符开头的连续子串**。

   后缀：**不包含第一个字符的所有以最后一个字符结尾的连续子串**。

   > 分析：字符串 `aabaa` 的最长公共前后缀是什么？有多长？
   >
   > 根据定义求出前缀： `a` 、 `aa` 、 `aab` 、 `aaba` ；
   >
   > 根据定义求出后缀： `abaa` 、 `baa` 、 `aa` 、 `a` ；
   >
   > 公共前后缀是 `a` 和 `aa` ，所以最长前后缀是 `aa` 且长度是 2 。

   **因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

3. 前缀表：**记录下标 i 之前（包括 i ）的字符串中，有多大长度的相同前缀后缀。**

   前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该**从哪里开始重新匹配**。

   前缀表的任务是当前位置匹配失败，<u>找到之前已经匹配上的位置，再重新匹配</u>，此也意味着在某个字符失配时，前缀表会告诉你<u>下一步匹配中，模式串应该跳到哪个位置</u>。

4.  next 数组：就可以看作是前缀表。很多 next 数组的实现都是把前缀表统一减一（右移一位，初始位置为 -1 ）之后作为 next 数组。

### 2. 实现思路

参考代码随想录网页: [点击这里](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%89%8D%E7%BC%80%E8%A1%A8) 。

### 3. 前缀表的代码实现

前缀表的元素 = 第 index 个元素**包括自己的**子字符串的**最长公共前后缀长度值**。

#### 3.1 构造前缀表数组（不减一版本）

```c++
void getNext(int* next, const string& s) {
    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```

#### 3.2 构造 next 数组（减一版本）

定义两个指针 `i` 和 `j` ， `j` 指向**前缀末尾位置**， `i` 指向**后缀末尾位置**。其中 `j` 被初始化为 `-1` ，这是因为我们规定 next 数组内的元素进行统一减一的操作。 `next[i]` 表示 `i`（包括 `i` ）之前最长相等的前后缀长度（记住有一个减 1 的操作，其实就是用 `j` 初始化）。

因为 `j` 初始化为 `-1` （记住有一个减 1 的操作，其实就是 `0-1=-1` ），那么 `i` 就从 `1` 开始，进行 `s[i]` 与 `s[j+1]` 的比较，故遍历模式串 `s` 的循环下标 `i` 要从 `1` 开始。

如果 `s[i]` 与 `s[j+1]`不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。 `next[j]` 就是记录着 `j` （包括 `j` ）之前的子串的相同前后缀的长度。那么当 `s[i]` 与 `s[j+1]` 不相同时，就要找 `j+1` 前一个元素在 `next` 数组里的值（就是 `next[j]` ）。

如果 `s[i]` 与 `s[j + 1]` 相同，说明找到了相同的前后缀，那么就同时向后移动 `i` 和 `j` ，同时还要将 `j` （前缀的长度）赋给 `next[i]` ，因为 `next[i]` 要记录相同前后缀的长度。

```c++
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

参考图片：

![ next 数据的生成](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif)

### 4. 如何使用前缀表（如何使用 next 数组来做匹配）

在文本串 `s` 里找是否出现过模式串 `t` 。定义两个下标 `j` 指向模式串起始位置， `i` 指向文本串起始位置。那么 `j` 初始值依然为 `-1` ，为什么呢？ **依然因为 next 数组里记录的起始位置为 `-1` 。**

`i` 就从 `0` 开始，遍历文本串，接下来就是 `s[i]` 与 `t[j+1]`  （因为 `j` 从 `-1`  开始的）进行比较。

如果 `s[i]` 与 `t[j+1]` 不相同， `j` 就要从 next 数组里寻找下一个匹配的位置。

如果 `s[i]` 与 `t[j+1]` 相同，那么 `i` 和 `j` 同时向后移动。

如果 `j` 指向了模式串 `t` 的末尾，那么就说明模式串 `t` 完全匹配文本串 `s` 里的某个子串了。

```c++
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
        j = next[j]; // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```





